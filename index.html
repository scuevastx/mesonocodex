<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mesono Sound Mixer</title>
  <style>
    /* Full-screen background image from GitHub */
    body {
      margin: 0;
      background: url('https://github.com/scuevastx/mesonocodex/blob/main/mesono-backimage.png?raw=true') no-repeat center center fixed;
      background-size: cover;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      text-align: center;
    }
    /* Canvas renders the orb & ripples */
    canvas {
      cursor: pointer;
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 0;
    }
    /* Direction labels & controls sit above canvas */
    .label {
      position: absolute;
      font-size: 1.1rem;
      font-weight: 700;
      z-index: 3;
      text-shadow: 0 2px 10px rgba(0,0,0,0.4);
      user-select: none;
    }
    /* Central brand mark placed between canvas and labels */
    #logoImage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 600px;
      max-height: 600px;
      z-index: 1;             /* ABOVE canvas, BELOW labels */
      pointer-events: none;    /* Don't block dragging */
      opacity: 0.25;           /* Ambient feel */
      display: block;          /* Ensure visible */
    }
    /* Simple pill styling for Start/Stop */
    .btn { padding: 6px 10px; border-radius: 999px; background: rgba(0,0,0,0.35); }
    .btn:hover { background: rgba(0,0,0,0.5); }

    /* Debug panel (togglable) */
    #debug {
      position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
      z-index: 4; background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 8px; font-size: 12px;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Center logo (ensure mesono-logo.png exists in the same folder) -->
  <img id="logoImage" src="mesono-logo.png" alt="Mesono Logo" />

  <!-- Labels: N/E/S/W & controls -->
  <div class="label" style="top: 5%; left: 50%; transform: translateX(-50%)">hz</div>
  <div class="label" style="top: 50%; left: 4%; transform: translateY(-50%)">music</div>
  <div class="label" style="top: 50%; right: 4%; transform: translateY(-50%)">white noise</div>
  <div class="label" style="bottom: 8%; left: 50%; transform: translateX(-50%)">pink noise</div>

  <div id="start" class="label btn" style="bottom: 6%; left: 4%">START</div>
  <div id="stop" class="label btn" style="bottom: 6%; right: 4%">STOP</div>
  <div id="testMusic" class="label btn" style="bottom: 6%; left: 50%; transform: translateX(-50%)">TEST MUSIC</div>

  <!-- Debug readout (press D to toggle) -->
  <div id="debug">g_hz: 0.00 | g_music: 0.00 | g_white: 0.00 | g_pink: 0.00 | music: loadingâ€¦</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Center & orb state
    const center = { x: 0, y: 0 };
    const orb = { x: 0, y: 0, radius: 25, dragging: false };

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      center.x = canvas.width / 2;
      center.y = canvas.height / 2;
      if (!orb.dragging) { // keep orb centered unless being dragged
        orb.x = center.x;
        orb.y = center.y;
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Distance from center to each point (for the mix curve)
    const ARM = 250;

    // Calibration to balance perceived loudness across sources
    const CAL = {
      'hz': 0.40,
      'music': 0.80,       // boost music so it stands out
      'white-noise': 0.06, // reduce noise layers further
      'pink-noise': 0.08
    };

    // Audio plumbing
    let audioCtx;
    const gainNodes = { hz: null, music: null, 'white-noise': null, 'pink-noise': null };
    let masterGain = null; // overall volume control
    const sources   = {};
    const ripples = [];

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Master gain with gentle fade-in
      masterGain = audioCtx.createGain();
      masterGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      masterGain.connect(audioCtx.destination);
      // Fade up to comfortable listening level
      const TARGET = 0.18; // overall volume
      masterGain.gain.exponentialRampToValueAtTime(TARGET, audioCtx.currentTime + 1.5);

      // Helper to create a noise chain with a gentle low shelf to tame harshness
      function makeNoise(type, shelfGainDb) {
        const bufferSize = 2 * audioCtx.sampleRate;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        src.buffer = noiseBuffer; src.loop = true;

        const shelf = audioCtx.createBiquadFilter();
        shelf.type = 'lowshelf';
        shelf.frequency.value = 200;      // lift/attenuate lows to soften brightness
        shelf.gain.value = shelfGainDb;   // negative number reduces rumble/boom

        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0, audioCtx.currentTime);

        src.connect(shelf).connect(g).connect(masterGain);
        src.start();
        sources[type] = src;
        gainNodes[type] = g;
      }

      // White / Pink noise (different shelves to balance tone color)
      makeNoise('white-noise', -6);
      makeNoise('pink-noise', -3);

      // Sine wave (Hz)
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 174; // base tone
      const hzGain = audioCtx.createGain();
      hzGain.gain.setValueAtTime(0.0, audioCtx.currentTime);
      osc.connect(hzGain).connect(masterGain);
      osc.start();
      gainNodes.hz = hzGain;

      // Music (preload file from same folder)
      fetch('mesono-theme.mp3', {cache:'no-store'})
        .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
        .then(buf => new Promise((res,rej)=> audioCtx.decodeAudioData(buf, res, rej)))
        .then(decoded => {
          const src = audioCtx.createBufferSource();
          src.buffer = decoded; src.loop = true;
          const mg = audioCtx.createGain();
          mg.gain.setValueAtTime(0.0, audioCtx.currentTime);
          src.connect(mg).connect(masterGain);
          src.start();
          sources.music = src;
          gainNodes.music = mg;
          console.log('[Mesono] Music buffer loaded.');
          const hud = document.getElementById('debug');
          if (hud && hud.style.display !== 'none') hud.textContent = hud.textContent.replace(/\| music:.*/, '| music: loaded');
        })
        .catch((e) => {
          console.warn('[Mesono] Buffer path failed, falling back to <audio> element.', e);
          let el = document.getElementById('musicEl');
          if(!el){
            el = document.createElement('audio');
            el.id = 'musicEl';
            el.src = 'mesono-theme.mp3';
            el.crossOrigin = 'anonymous';
            el.preload = 'auto';
            el.loop = true;
            el.style.display = 'none';
            document.body.appendChild(el);
          }
          const srcNode = audioCtx.createMediaElementSource(el);
          const mg = audioCtx.createGain();
          mg.gain.setValueAtTime(0.0, audioCtx.currentTime);
          srcNode.connect(mg).connect(masterGain);
          gainNodes.music = mg;
          sources.music = el;
          el.play().then(()=>{
            const hud = document.getElementById('debug');
            if (hud && hud.style.display !== 'none') hud.textContent = hud.textContent.replace(/\| music:.*/, '| music: playing');
          }).catch(err=>{
            console.warn('[Mesono] Music element failed to play', err);
          });
        });
    }

    // Hotspot mixing: each point peaks at its own location with Gaussian falloff
    function updateGains() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const T = 0.06; // smoothing

      // Hotspot radius (controls how wide each island feels)
      const HOTSPOT_R = 180;
      const R2 = 2 * HOTSPOT_R * HOTSPOT_R; // for Gaussian falloff

      // Absolute positions of the four points
      const pos = {
        'hz':          { x: center.x,       y: center.y - ARM },
        'music':       { x: center.x - ARM, y: center.y       },
        'white-noise': { x: center.x + ARM, y: center.y       },
        'pink-noise':  { x: center.x,       y: center.y + ARM }
      };

      // Radial Gaussian falloff: peak at the point, fades as you move away
      const targets = {};
      for (const key of Object.keys(pos)) {
        const dx = orb.x - pos[key].x;
        const dy = orb.y - pos[key].y;
        const d2 = dx*dx + dy*dy;
        const radial = Math.exp(-d2 / R2); // 1 at point, ~0 far away
        targets[key] = CAL[key] * radial;
      }

      for (const key of Object.keys(targets)) {
        const node = gainNodes[key];
        if (!node) continue;
        const target = Math.max(0.0001, Math.min(1, targets[key]));
        node.gain.setTargetAtTime(target, now, T);
      }

      // Debug HUD
      const hud = document.getElementById('debug');
      if (hud && hud.style.display !== 'none') {
        hud.textContent = `g_hz: ${targets.hz.toFixed(2)} | g_music: ${targets.music.toFixed(2)} | g_white: ${targets['white-noise'].toFixed(2)} | g_pink: ${targets['pink-noise'].toFixed(2)}`;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Ripples
      for (let i = ripples.length - 1; i >= 0; i--) {
        const r = ripples[i];
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${r.alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        r.radius += 2;
        r.alpha -= 0.01;
        if (r.alpha <= 0) ripples.splice(i, 1);
      }

      // Concentric guides
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      for (let i = 1; i <= 6; i++) {
        ctx.beginPath();
        ctx.arc(center.x, center.y, i * 60, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Orb
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#000';
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function animate() {
      draw();
      updateGains();
      requestAnimationFrame(animate);
    }
    animate();

    // Interactions
    canvas.addEventListener('mousedown', (e) => {
      const dx = e.clientX - orb.x;
      const dy = e.clientY - orb.y;
      if (Math.hypot(dx, dy) < orb.radius) orb.dragging = true;
    });
    canvas.addEventListener('mouseup',   () => (orb.dragging = false));
    canvas.addEventListener('mouseleave',() => (orb.dragging = false));
    canvas.addEventListener('mousemove', (e) => {
      if (orb.dragging) {
        orb.x = e.clientX;
        orb.y = e.clientY;
        ripples.push({ x: orb.x, y: orb.y, radius: 10, alpha: 0.5 });
      }
    });

    // START/STOP handlers (user gesture required to start audio)
    document.getElementById('start').onclick = function () {
      if (!audioCtx) { initAudio(); return; }
      const now = audioCtx.currentTime;
      masterGain.gain.cancelScheduledValues(now);
      // ensure we ramp from a tiny positive value
      const from = Math.max(masterGain.gain.value, 0.0001);
      masterGain.gain.setValueAtTime(from, now);
      masterGain.gain.exponentialRampToValueAtTime(0.18, now + 1.0);
    };

    document.getElementById('stop').onclick = function () {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setTargetAtTime(0.0001, now, 0.2);
      // If using media element fallback, pause it while stopped
      if (sources.music instanceof HTMLAudioElement) {
        sources.music.pause();
      }
    };

    // Debug toggle (press D)
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'd') {
        const hud = document.getElementById('debug');
        hud.style.display = hud.style.display === 'none' ? 'block' : 'none';
      }
    });

    // TEST MUSIC: briefly bring up the music layer to confirm it plays
    document.getElementById('testMusic').onclick = function(){
      if (!audioCtx) initAudio();
      const now = audioCtx.currentTime;
      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setTargetAtTime(0.18, now, 0.05);
      if (gainNodes.music) {
        gainNodes.music.gain.setTargetAtTime(0.6, now, 0.05);
        setTimeout(()=>{
          const n = audioCtx.currentTime;
          gainNodes.music.gain.setTargetAtTime(0.0001, n, 0.15);
        }, 1500);
      }
      if (sources.music instanceof HTMLAudioElement && sources.music.paused) {
        sources.music.play().catch(()=>{});
      }
    };
        hud.style.display = hud.style.display === 'none' ? 'block' : 'none';
      }
    });

    // --- Lightweight self-tests to guard against future regressions ---
    (function runSelfTests() {
      try {
        console.assert(document.getElementById('canvas'), 'Canvas exists');
        console.assert(document.getElementById('logoImage'), 'Logo image exists');
        console.assert(typeof updateGains === 'function', 'updateGains is defined');
        console.assert(['hz','music','white-noise','pink-noise'].every(k => k in CAL), 'CAL has all layers');
        console.assert(document.querySelectorAll('#logoImage').length === 1, 'No duplicate logoImage IDs');
        console.assert(typeof document.getElementById('start').onclick === 'function', 'START handler attached');
        console.assert(typeof document.getElementById('stop').onclick === 'function', 'STOP handler attached');
        // Gaussian sanity: at zero distance radial=1; far away ~0
        const R2test = 2 * 100 * 100; // mimic HOTSPOT_R=100
        const near = Math.exp(-0 / R2test);
        const far = Math.exp(-(1000*1000) / R2test);
        console.assert(Math.abs(near - 1) < 1e-6, 'Gaussian near=1');
        console.assert(far < 1e-3, 'Gaussian far~0');
        // Safe to call updateGains before audio is initialized
        updateGains();
        console.log('[Mesono] Self-tests passed');
      } catch (e) {
        console.error('[Mesono] Self-tests failed', e);
      }
    })();
  </script>
</body>
</html>

